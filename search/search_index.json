{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About this page","text":"<p>Sharing knowledge about anything &lt;3</p>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<p>This page is powered by mkdocs.org and using mkdocs material.</p> <p>To contribute kindly:</p> <ol> <li>Clone the repo</li> <li>Read the template document here</li> <li>Add new pages by creating PR to <code>master</code> branch</li> </ol>"},{"location":"#mkdocs-commands","title":"Mkdocs Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#some-sample-components","title":"Some sample components","text":""},{"location":"#tabs","title":"Tabs","text":"Sample Tab 1Sample Tab 2 <p>Markdown content.</p> <p>Multiple paragraphs.</p> <p>More Markdown content.</p> <ul> <li>list item a</li> <li>list item b</li> </ul>"},{"location":"#content-tabs-with-code-blocks","title":"Content Tabs with code blocks","text":"<p>Example</p> C <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> C++ <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre> Python bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#diagrams","title":"Diagrams","text":""},{"location":"#flowchart","title":"Flowchart","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre>"},{"location":"gitflow/","title":"Git Flow","text":"<p>Stolen from here</p> <p>Table of Contents</p> <ul> <li>Git Flow</li> <li>Introduction</li> <li>Requirements and Tips</li> <li>The workflow<ul> <li>Important</li> <li>Branches</li> <li>master branch</li> <li>dev branch</li> <li>RC branch</li> <li>HotFix branch</li> <li>FEATURE/TICKET branches</li> <li>Roles</li> </ul> </li> <li>User stories<ul> <li>Developers</li> <li>Prepare the environment</li> <li>Create a feature branch</li> <li>Sync your feature branch</li> <li>Request to pull</li> <li>Create patches</li> <li>Apply a patch</li> <li>Release manager</li> <li>Prepare the environment</li> <li>Process pull requests</li> <li>Prepare a Release Candidate</li> <li>Hot Fixes</li> </ul> </li> <li>Tips and HOWTOs<ul> <li>How to recover after upstream branch was rebased.</li> </ul> </li> </ul>"},{"location":"gitflow/#introduction","title":"Introduction","text":"<p>This document describes a git workflow for development teams. The workflow aims to provide:</p> <ul> <li>uninterruptible development,</li> <li>a stable and releasable at any time master,</li> <li>a multilevel protection against conflicts,</li> <li>a multilevel possibility to recover from errors/mistakes before changes come into the master,</li> <li>a clean, leaner history of the master branch without merge commits and other unwanted garbage.</li> </ul> <p>Treat public history as immutable, atomic, and easy to follow. Treat private history as disposable and malleable.</p>"},{"location":"gitflow/#requirements-and-tips","title":"Requirements and Tips","text":"<ul> <li>Use one branch per feature/bug (contained development).    Every tick/task/feature MUST be implemented on a separate branch. Basically each JIRA ticket should be represented by at least one branch.</li> <li>Only release managers are allowed to work on the central master branch.</li> <li>Cherry picking MUST not be used by any means.</li> <li>A good use of branches should prevent the need of \"git cherry-pick\".</li> <li>DO NOT create very large repositories.</li> <li>DO NOT commit large binary files.</li> <li>DO NOT commit any file, which can be regenerated or which is generated automatically by your development environment.</li> <li>Remember to rebase your feature branch before merging it to the Development branch.</li> <li>Specify the origin and branch when pushing (might avoid mistakes).</li> <li>Use \"git pull --rebase\" in order to avoid merges from upstream commits.</li> </ul>"},{"location":"gitflow/#the-workflow","title":"The workflow","text":""},{"location":"gitflow/#important","title":"Important","text":"<p>In your development process, you must strictly distinguish between Features, Fixes and Hot Fixes.</p> <ul> <li>Features, Fixes - are patches, which can wait until the next release of the product. This is why they travail starting from private feature branches ---&gt; the central dev branch ---&gt; the central release branch ---&gt; the central master</li> <li>Hot Fixes - are the patches, which can't wait and must be applied directly on a release version of the product. This is why they have completely different path: a new private branch from the given tag on the central master  ---&gt; central master.</li> </ul>"},{"location":"gitflow/#branches","title":"Branches","text":"<p>There are only a few long term branches - master and dev. All other branches should be deleted as soon as their commits are merged into the master or you don't need them.</p> <p>Use the following command to find out branches, which a merged into the mainrepo/master:</p> <pre><code>git branch --merged mainrepo/master\n</code></pre> <p>or not merged:</p> <pre><code>git branch --no-merged mainrepo/master\n</code></pre>"},{"location":"gitflow/#master-branch","title":"master branch","text":"<p>Contains all the stable, released code.</p> <ul> <li>All released versions of all modules should be tagged in the master.</li> <li>No separate branches for the released versions.</li> <li>The master branch is ready to build at any moment.</li> <li>No development should be performed on the master branch directly.</li> <li>Only release managers have write permissions on it.</li> <li>The master branch rolls only forward, no history changes are allowed on the master branch.</li> <li>All new patches are introduced in the master branch only via \"git merge --ff-only\".</li> </ul>"},{"location":"gitflow/#dev-branch","title":"dev branch","text":"<ul> <li>The branch is inherited from the latest master.</li> <li>The dev branch is a development mainstream.</li> <li>A release manager defines a list of tasks for a development sprint. For each task, developers MUST create a separate branch inherited from the dev branch.</li> <li>Should be rebased from the master each time master is changed.</li> </ul>"},{"location":"gitflow/#rc-branch","title":"RC branch","text":"<p>RC or ReleaseCandidate branch is a temporary branch. This branch intends to provide uninterruptible development - to avoid such mails like \"Please do not commit..., we freeze a branch\" :).</p> <p>At the moment of a release, a release manager will branch from dev to create an RC branch to start a release procedure. It also means feature freeze on the RC branch and only bug fixes can be introduced on it - no commits with new features.</p> <p>While a release manager works on the RC branch, all developers continue developing in dev and in their feature branches - uninterruptible development.</p> <p>The branch should be deleted as soon as it has been merged with the master. Once the RC branch is merged into the master, the dev branch should be rebased from the master. The rebases might require a parent commit change, if git is not able to rebase automatically.</p>"},{"location":"gitflow/#hotfix-branch","title":"HotFix branch","text":"<p>It is a branch for hot fixes. It should contain only urgent hot fixes for the released versions, which can't wait until the next scheduled release of the product.</p> <p>Once a hot fix is merged back in to the master, the dev branch should be rebased from the master to get new changes.</p> <p>The branch should be deleted as soon as merged with the master.</p>"},{"location":"gitflow/#featureticket-branches","title":"FEATURE/TICKET branches","text":"<p>Each business or development task/ticket/feature should have at least one feature branch. Such branches must be rebased to dev as often as possible to simplify future merging.</p> <p>Rebasing is important to keep new commits together for possible tuning or squashing in the feature.</p> <p>Whenever a feature is ready (or a stable part of the feature) it can be merged with the dev branch.</p> <p>It is recommended to keep feature branches even after their merge with dev. It will simplify fine tuning in case if the feature represented by the branch will be reverted from the dev for additional development or fixes/corrections.</p> <p>Feature branches should be deleted as soon as their commits are merged into the master via the dev branch.</p>"},{"location":"gitflow/#roles","title":"Roles","text":"<p>Release manager (r/w: MASTER, DEV, RC) Developer (r/w: FEATURE(s), HOT FIX; read only: MASTER, DEV)</p>"},{"location":"gitflow/#user-stories","title":"User stories","text":"<p>In the following documentation we use:</p> <ul> <li>mainrepo_url - the url of the main repo, which is restricted and managed by release managers only. Developers must not have write permissions on it.</li> <li>mainrepo - the name of the main repo.</li> <li>url_of_the_fork - the url of your fork repo of the main repo.</li> <li>developerrepo_url - the url of a developer's repo.</li> </ul>"},{"location":"gitflow/#developers","title":"Developers","text":""},{"location":"gitflow/#prepare-the-environment","title":"Prepare the environment","text":"<ol> <li> <p>setup git configuration. The following you have yo execute on all of your machines, or copy the git config to all of your machines.</p> <pre><code>git config --global branch.autosetuprebase always\ngit config --global user.name \"FirsName LastName\"\ngit config --global user.email johndoe@example.com\ngit config --global core.ignorecase false\n</code></pre> </li> <li> <p>Using github fork the main repo.</p> </li> <li> <p>Create a local copy of the forked repo:</p> <pre><code>git clone url_of_the_fork\n</code></pre> </li> <li> <p>Now when your origin points to your fork. You need to add the main repo to your remotes as well.     You should have \"origin --&gt; you fork\" and \"mainrepo --&gt; the main repo\".</p> <pre><code>git remote add mainrepo mainrepo_url\ngit fetch mainrepo\n</code></pre> </li> <li> <p>Create a local dev branch</p> <pre><code>git checkout -b dev mainrepo/dev\n</code></pre> </li> <li> <p>Push the local dev to your remote (forked repo):</p> <pre><code>git push -u origin dev\n</code></pre> </li> </ol>"},{"location":"gitflow/#create-a-feature-branch","title":"Create a feature branch","text":"<p>Each task or ticket MUST be developed in a separate branch.</p> <ol> <li> <p>Create a feature branch from the latest stat of the central dev.</p> <pre><code>git fetch mainrepo\ngit checkout -b featureXXX mainrepo/dev\n</code></pre> </li> <li> <p>Push the feature branch to your fork and track it</p> <pre><code>git push -u origin featureXXX\n</code></pre> </li> </ol>"},{"location":"gitflow/#sync-your-feature-branch","title":"Sync your feature branch","text":"<p>As often as possible sync your feature branch with the central dev.</p> <ol> <li> <p>Sync:</p> <p><pre><code>git fetch mainrepo\ngit checkout featureXXX\ngit rebase mainrepo/dev\n</code></pre> * Resolve conflicts if any. * Stage each modified file \"git add \" after conflicts are resolved. * You can also use \"git checkout --theirs/--ours \" to help to resolve conflicts. * Use \"git rebase --continue\" to continue rebasing. <li> <p>push to you remote clone:</p> <p><pre><code>git push origin\n</code></pre> Most probably your local repo and the remote repo will be diverged at this point. Git will warn you that you are about to change the history and will not allow you to push.</p> <p>Please, revise the output to make sure that you are actually pushing to the right repo and only after that execute the following to force (--force-with-lease) git to change the history.</p> <pre><code>git push --force-with-lease origin\n</code></pre> <p>We recommend to do push in two steps intuitionally to prevent unwanted changes. Even if you are 100% sure, ALWAYS first execute \"git push\" without \"--force-with-lease\". Revise the output. Check that the repo you are pushing is the the one you want and only then force push with \"--force-with-lease\".</p> </li>"},{"location":"gitflow/#request-to-pull","title":"Request to pull","text":"<ol> <li> <p>Always rebase to the main dev before requesting to pull.</p> <p><pre><code>git fetch mainrepo\ngit checkout featureXXX\ngit rebase mainrepo/dev\n</code></pre> * Resolve conflicts if any. * Stage each modified file \"git add \" after conflicts are resolved. * You can also use \"git checkout --theirs/--ours \" to help to resolve conflicts. * Use \"git rebase --continue\" to continue rebasing. <li> <p>Squash all of your commits. Once your code is perfect, clean up its history.</p> <pre><code>git rebase -i mainrepo/dev\n</code></pre> <p>It is very important for the history of the main repository that all of your commits are squashed. In the future nobody is interested to see your \"cosmetic changes\" commits or commits related to any other minor changes. The best way to introduce a feature is to introduce it as a patch. This is why, do squash all your commits into one, write a good proper comment before requesting to pull your code.</p> </li> <li> <p>Push your changes to your remote repo. You may need to use \"push -f\" since after the rebase your remote repo can be diverged from the local repo.</p> <pre><code>git push --force-with-lease origin\n</code></pre> </li> <li> <p>Request to pull. Let your release manager know that you want your patch to be merged with the central dev branch. Use a simple email or github to send a pull request.</p> </li> <p>Stop working on the featureXXX branch, after you sent a request to pull. Create a new branch for any other feature/ticket/bug.</p>"},{"location":"gitflow/#create-patches","title":"Create patches","text":"<p>Just in case if you can't just push or request to pull your changes, you can create a git patch.</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\ngit format-patch origin/master --stdout &gt; a_fix.patch\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>The command above will create a patch, of the changes which differ you from the \"origin/master\" branch.</p>"},{"location":"gitflow/#apply-a-patch","title":"Apply a patch","text":"<pre><code>~~~~~~~~~~~~~~~~~~~~~\ngit am --signoff &lt; a_fix.patch\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>If there are different line ending settings between source and dest. machines you may want to either ignore space changes - but in this case git will create a new commit ID</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\ngit am --ignore-space-change --ignore-whitespace --signoff &lt; a_fix.patch\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>or try to preserver cr or the patch 0 (but this will cause a warning about trailing whitespaces).</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\ngit am --keep-cr --signoff &lt; a_fix.patch\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre>"},{"location":"gitflow/#release-manager","title":"Release manager","text":"<p>The write access to the repository is restricted to release managers only. The repository contains the following permanent branches: master, dev. The \"RC\" and \"HotFix\" are created (branched) only when we need them and deleted as soon as their commits are merged into the master or when we don't need those branches.</p>"},{"location":"gitflow/#prepare-the-environment_1","title":"Prepare the environment","text":"<ol> <li> <p>setup git configuration. The following you have yo execute on all of your machines, or copy the git config to all of your machines.</p> <pre><code>git config --global branch.autosetuprebase always\ngit config --global user.name \"FirsName LastName\"\ngit config --global user.email johndoe@example.com\ngit config --global core.ignorecase false\n</code></pre> </li> <li> <p>Using github fork the main repo.</p> </li> <li> <p>Create a local copy of the forked repo:</p> <pre><code>git clone url_of_the_fork\n</code></pre> </li> <li> <p>Now when your origin points to your fork. You need to add the main repo to your remotes as well.     You should have \"origin --&gt; you fork\" and \"mainrepo --&gt; the main repo\".</p> <pre><code>git remote add mainrepo mainrepo_url\ngit fetch mainrepo\n</code></pre> </li> <li> <p>create a local dev branch with upstream to the mainrepo/dev.</p> <pre><code>git checkout -t -b dev mainrepo/dev\n</code></pre> </li> </ol>"},{"location":"gitflow/#process-pull-requests","title":"Process pull requests","text":"<p>You can process pull requests automatically if you are using GitLab or GitHub. Both vendors offer users a possbility to use fast forward merging.</p> <p>GitLab: https://docs.gitlab.com/ee/user/project/merge_requests/fast_forward_merge.html (\"Fast-forward merge\")</p> <p>GitHub: https://help.github.com/articles/merging-a-pull-request/ (\"Rebase and merge\")</p> <ol> <li> <p>update</p> <pre><code>git fetch origin\ngit fetch mainrepo\n</code></pre> </li> <li> <p>Add the developer's repo to your remotes. You need to do it only once per developer, when you for the first time fetch from this developer</p> <pre><code>git remote add dev_name developerrepo_url\ngit fetch dev_name\n</code></pre> </li> <li> <p>Now merge the changes the developer has provided</p> <p><pre><code>git checkout -f dev\ngit rebase mainrepo/dev\ngit merge --ff-only dev_name/featureXXX\n</code></pre>    If there are conflicts or git says, that it can't use fast forward, than reject the request and ask developer to rebase from the main dev branchy again, fix conflicts if needed and send a new pull request.</p> </li> <li> <p>If no conflicts are found, push this commit to the main dev branch:</p> <pre><code>git push mainrepo dev:dev\n</code></pre> </li> </ol>"},{"location":"gitflow/#prepare-a-release-candidate","title":"Prepare a Release Candidate","text":""},{"location":"gitflow/#hot-fixes","title":"Hot Fixes","text":""},{"location":"gitflow/#tips-and-howtos","title":"Tips and HOWTOs","text":""},{"location":"gitflow/#how-to-recover-after-upstream-branch-was-rebased","title":"How to recover after upstream branch was rebased.","text":"<p>The following tip will help us to recover in cases when you or your colleague had to change something in the history of a high level branch (our upstream). It can be easily the case when you need to change history (rebase, move/delete/squash commits, etc.) of the DEV branch, for example. When the history of dev branch is changed, then all branches inherited from it (feature branches) will have problems to rebase on it, because all commits, which differ you from the dev branch will be consider by git as new (your) changes and it will try to merge them.</p> <p>Let's take an example. Dev before change of the history and F is your feature branch:</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\nC0\n|\nC1\n|\nC2\n|\\\nC3 cf1\nC4 cf2\n ~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>\u2018DEV\u2019 has C1,C2,C3,C4 \u2018F\u2019 has C1,C2,cf1,cf2</p> <p>After the change of the history of the DEV it looks like:</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\nC0\n|\nC1x\n|\nC2x\n|\nC3x\nC4x\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>And F still looks like:</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\nC0\n|\nC1\n|\nC2\n|\ncf1\n|\ncf2\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>For git commits C1, C2 is now different from the commits C1x, C2x from the DEV branch. To avoid merging nightmare and duplications of the commits we have to just change the parent commit of our commits in the feature branch. The commits cf1, cf2 is our commits belonging to the new feature. At the moment their parent is C2.</p> <p>So, what basically happened is that our feature branch is not forked from the changed DEV anymore. But we want it to depend on the DEV. What we need is only to move commits of the feature branch to a new parent - C2x.</p> <p>Fortunately git can easily help us to fix our problem. Checkout your feature branch you want to fix and execute the following:</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\ngit fetch mainrepo\ngit rebase --onto mainrepo/dev dev F\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>This basically says, \u201cCheck out the F branch, figure out the patches from the common ancestor of the mainrepo/dev and our local dev (which is not changed yet) branches, and then replay them onto master.\u201d If you don't have a local, unchanged version of the DEV branch, then you can even manually find out the commit ID, which is the last common between the new DEV and your F branch and execute:</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~\ngit rebase --onto &lt;new-parent&gt; &lt;old-parent&gt; F\n~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>HERE find more on this</p>"},{"location":"graph/","title":"Knowledge Graphs","text":"<p>Mind maps for different domains</p>"},{"location":"graph/#sample-graphs","title":"Sample graphs","text":"<pre><code>mindmap\n  root((mindmap))\n    Origins\n      Long history\n      ::icon(fa fa-book)\n      Popularisation\n        British popular psychology author Tony Buzan\n    Research\n      On effectiveness&lt;br/&gt;and features\n      On Automatic creation\n        Uses\n            Creative techniques\n            Strategic planning\n            Argument mapping\n    Tools\n      Pen and paper\n      Mermaid</code></pre>"}]}